const api = require('./apiConfig');
const nodeFetch = require('node-fetch');
const { HttpsProxyAgent } = require('https-proxy-agent');
const crypto = require('crypto');
const fs = require('fs');
const path = require('path');

// Êó•ÂøóÁ≥ªÁªü
class Logger {
    constructor() {
        this.logDir = './logs';
        this.logFile = null;
        this.init();
    }

    init() {
        // ÂàõÂª∫logsÁõÆÂΩï
        if (!fs.existsSync(this.logDir)) {
            fs.mkdirSync(this.logDir, { recursive: true });
        }

        // ÂàõÂª∫Êñ∞ÁöÑÊó•ÂøóÊñá‰ª∂
        const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
        this.logFile = path.join(this.logDir, `aster-tool-${timestamp}.log`);
        
        // ÂÜôÂÖ•ÂêØÂä®‰ø°ÊÅØ
        this.log(`üöÄ Aster ÂØπÂÜ≤‰∫§ÊòìÂ∑•ÂÖ∑ÂêØÂä® - ${new Date().toLocaleString('zh-CN')}`);
    }

    log(message) {
        const timestamp = new Date().toLocaleString('zh-CN');
        const logMessage = `[${timestamp}] ${message}`;
        
        // ËæìÂá∫Âà∞ÊéßÂà∂Âè∞
        console.log(message);
        
        // ÂÜôÂÖ•Êñá‰ª∂
        fs.appendFileSync(this.logFile, logMessage + '\n');
    }

    error(message) {
        const timestamp = new Date().toLocaleString('zh-CN');
        const logMessage = `[${timestamp}] ERROR: ${message}`;
        
        // ËæìÂá∫Âà∞ÊéßÂà∂Âè∞
        console.error(message);
        
        // ÂÜôÂÖ•Êñá‰ª∂
        fs.appendFileSync(this.logFile, logMessage + '\n');
    }
}

// ÂàõÂª∫ÂÖ®Â±ÄÊó•ÂøóÂÆû‰æã
const logger = new Logger();

class AsterFuturesAPI {
    constructor(apiKey, apiSecret, accountName = 'default', proxyConfig = null) {
        this.apiKey = apiKey;
        this.apiSecret = apiSecret;
        this.accountName = accountName;
        this.baseURL = 'https://fapi.asterdex.com';
        this.proxyUrl = null;
        this.proxyAgent = null;
        this.proxyConfig = proxyConfig;
        this.initProxy();
    }

    // ÂàùÂßãÂåñ‰ª£ÁêÜËÆæÁΩÆ
    initProxy() {
        if (this.proxyConfig && this.proxyConfig.enabled) {
            try {
                this.proxyUrl = this.proxyConfig.url;
                this.proxyAgent = new HttpsProxyAgent(this.proxyConfig.url);
                logger.log(`[${this.accountName}] ‰ª£ÁêÜÂ∑≤ÂêØÁî®: ${this.proxyConfig.url}`);
            } catch (error) {
                logger.error(`[${this.accountName}] ‰ª£ÁêÜËÆæÁΩÆÂ§±Ë¥•: ${error.message}`);
                this.proxyUrl = null;
                this.proxyAgent = null;
            }
        } else {
            logger.log(`[${this.accountName}] ‰ª£ÁêÜÊú™ÂêØÁî®`);
        }
    }

    // Âä®ÊÄÅËÆæÁΩÆ‰ª£ÁêÜ
    setProxy(proxyUrl) {
        try {
            if (proxyUrl) {
                this.proxyUrl = proxyUrl;
                this.proxyAgent = new HttpsProxyAgent(proxyUrl);
                logger.log(`[${this.accountName}] ‰ª£ÁêÜÂ∑≤Êõ¥Êñ∞: ${proxyUrl}`);
            } else {
                this.proxyUrl = null;
                this.proxyAgent = null;
                logger.log(`[${this.accountName}] ‰ª£ÁêÜÂ∑≤Á¶ÅÁî®`);
            }
        } catch (error) {
            logger.error(`[${this.accountName}] ‰ª£ÁêÜËÆæÁΩÆÂ§±Ë¥•: ${error.message}`);
        }
    }

    // Ëé∑ÂèñÂΩìÂâç‰ª£ÁêÜÁä∂ÊÄÅ
    getProxyStatus() {
        return {
            enabled: !!this.proxyAgent,
            url: this.proxyUrl,
            agent: this.proxyAgent ? 'Â∑≤ÈÖçÁΩÆ' : 'Êú™ÈÖçÁΩÆ'
        };
    }

    generateSignature(queryString) {
        return crypto.createHmac('sha256', this.apiSecret).update(queryString).digest('hex');
    }

    async makeRequest(method, endpoint, params = {}, needAuth = false) {
        try {
            let url = `${this.baseURL}${endpoint}`;
            let queryString = '';
            let body = null;
            
            const headers = {
                'Content-Type': 'application/x-www-form-urlencoded',
                'User-Agent': 'AsterAPI/1.0'
            };

            if (needAuth) {
                params.timestamp = Date.now();
                params.recvWindow = params.recvWindow || 5000;
                headers['X-MBX-APIKEY'] = this.apiKey;
            }

            if (Object.keys(params).length > 0) {
                queryString = new URLSearchParams(params).toString();
                if (needAuth) {
                    const signature = this.generateSignature(queryString);
                    queryString += `&signature=${signature}`;
                }
            }

            if (method === 'GET') {
                if (queryString) {
                    url += `?${queryString}`;
                }
            } else if (method === 'POST' || method === 'PUT' || method === 'DELETE') {
                if (queryString) {
                    body = queryString;
                }
            }

            const fetchOptions = {
                method,
                headers,
                body
            };

            // ‰ΩøÁî®‰ª£ÁêÜ
            if (this.proxyAgent) {
                fetchOptions.agent = this.proxyAgent;
            }

            const response = await nodeFetch(url, fetchOptions);

            if (!response.ok) {
                let errorMessage = `HTTP error! status: ${response.status}`;
                try {
                    const errorBody = await response.text();
                    if (errorBody) {
                        errorMessage += `, response: ${errorBody}`;
                    }
                } catch (e) {
                    // ÂøΩÁï•ËØªÂèñÂìçÂ∫î‰ΩìÁöÑÈîôËØØ
                }
                throw new Error(errorMessage);
            }

            const result = await response.json();
            return result;
        } catch (error) {
            logger.error(`[${this.accountName}] ËØ∑Ê±ÇÂ§±Ë¥•: ${error.message}`);
            throw error;
        }
    }

    async getPrice(symbol) {
        const response = await this.makeRequest('GET', '/fapi/v1/ticker/price', { symbol });
        return response;
    }

    async getOrderBook(symbol, limit = 5) {
        const validLimits = [5, 10, 20, 50, 100, 500, 1000];
        const finalLimit = validLimits.includes(limit) ? limit : 5;
        
        const response = await this.makeRequest('GET', '/fapi/v1/depth', { symbol, limit: finalLimit });
        return response;
    }

    async getBid1Price(symbol) {
        try {
            const orderBook = await this.getOrderBook(symbol, 5);
            if (orderBook.bids && orderBook.bids.length > 0) {
                const bid1Price = parseFloat(orderBook.bids[0][0]);
                logger.log(`[${this.accountName}] ${symbol} ‰π∞1‰ª∑Ê†º: ${bid1Price}`);
                return bid1Price;
            }
            throw new Error('Êó†Ê≥ïËé∑Âèñ‰π∞1‰ª∑Ê†º');
        } catch (error) {
            logger.error(`[${this.accountName}] Ëé∑Âèñ‰π∞1‰ª∑Ê†ºÂ§±Ë¥•: ${error.message}`);
            throw error;
        }
    }

    async getAsk1Price(symbol) {
        try {
            const orderBook = await this.getOrderBook(symbol, 5);
            if (orderBook.asks && orderBook.asks.length > 0) {
                const ask1Price = parseFloat(orderBook.asks[0][0]);
                logger.log(`[${this.accountName}] ${symbol} Âçñ1‰ª∑Ê†º: ${ask1Price}`);
                return ask1Price;
            }
            throw new Error('Êó†Ê≥ïËé∑ÂèñÂçñ1‰ª∑Ê†º');
        } catch (error) {
            logger.error(`[${this.accountName}] Ëé∑ÂèñÂçñ1‰ª∑Ê†ºÂ§±Ë¥•: ${error.message}`);
            throw error;
        }
    }

    async getPositions(symbol = null) {
        const params = symbol ? { symbol } : {};
        const response = await this.makeRequest('GET', '/fapi/v2/positionRisk', params, true);
        return response;
    }

    async setLeverage(symbol, leverage) {
        const response = await this.makeRequest('POST', '/fapi/v1/leverage', {
            symbol,
            leverage
        }, true);
        return response;
    }

    async placeOrder(orderParams) {
        const response = await this.makeRequest('POST', '/fapi/v1/order', orderParams, true);
        return response;
    }

    async buyOrder(symbol, quantity, price = null, type = 'MARKET', positionSide = 'BOTH') {
        // BTCÂ∏ÇÂú∫ÈôêÂà∂‰∏∫3‰ΩçÂ∞èÊï∞
        const formattedQuantity = parseFloat(quantity).toFixed(3);
        
        const orderParams = {
            symbol: symbol,
            side: 'BUY',
            type: type,
            quantity: formattedQuantity,
            positionSide: positionSide
        };

        if (type === 'LIMIT' && price) {
            orderParams.price = price.toString();
            orderParams.timeInForce = 'GTC';
        }

        return await this.placeOrder(orderParams);
    }

    async sellOrder(symbol, quantity, price = null, type = 'MARKET', positionSide = 'BOTH') {
        // BTCÂ∏ÇÂú∫ÈôêÂà∂‰∏∫3‰ΩçÂ∞èÊï∞
        const formattedQuantity = parseFloat(quantity).toFixed(3);
        
        const orderParams = {
            symbol: symbol,
            side: 'SELL',
            type: type,
            quantity: formattedQuantity,
            positionSide: positionSide
        };

        if (type === 'LIMIT' && price) {
            orderParams.price = price.toString();
            orderParams.timeInForce = 'GTC';
        }

        return await this.placeOrder(orderParams);
    }

    async closePosition(symbol, quantity = null) {
        try {
            const positions = await this.getPositions(symbol);
            
            if (!positions || positions.length === 0) {
                logger.log(`[${this.accountName}] Ê≤°ÊúâÊâæÂà∞ ${symbol} ÁöÑÊåÅ‰ªì`);
                return null;
            }

            for (const position of positions) {
                const positionAmt = parseFloat(position.positionAmt);
                if (positionAmt === 0) continue;

                const closeQuantity = quantity || Math.abs(positionAmt);
                // BTCÂ∏ÇÂú∫ÈôêÂà∂‰∏∫3‰ΩçÂ∞èÊï∞
                const formattedCloseQuantity = parseFloat(closeQuantity).toFixed(3);
                let orderParams;

                if (positionAmt > 0) {
                    orderParams = {
                        symbol: symbol,
                        side: 'SELL',
                        type: 'MARKET',
                        quantity: formattedCloseQuantity,
                        reduceOnly: 'true',
                        positionSide: position.positionSide
                    };
                } else {
                    orderParams = {
                        symbol: symbol,
                        side: 'BUY',
                        type: 'MARKET',
                        quantity: formattedCloseQuantity,
                        reduceOnly: 'true',
                        positionSide: position.positionSide
                    };
                }

                const result = await this.placeOrder(orderParams);
                logger.log(`[${this.accountName}] Âπ≥‰ªìÊàêÂäü: ${closeQuantity} ${symbol}`);
                return result;
            }

            logger.log(`[${this.accountName}] Ê≤°ÊúâÈúÄË¶ÅÂπ≥‰ªìÁöÑÊåÅ‰ªì`);
            return null;
        } catch (error) {
            logger.error(`[${this.accountName}] Âπ≥‰ªìÂ§±Ë¥•: ${error.message}`);
            throw error;
        }
    }

    async getOrderStatus(symbol, orderId) {
        const response = await this.makeRequest('GET', '/fapi/v1/order', {
            symbol,
            orderId
        }, true);
        return response;
    }

    async monitorOrderStatus(symbol, orderId, maxWaitTime = 300000) {
        const startTime = Date.now();
        logger.log(`[${this.accountName}] ÂºÄÂßãÁõëÊéßËÆ¢Âçï ${orderId} Áä∂ÊÄÅ...`);
        
        while (Date.now() - startTime < maxWaitTime) {
            try {
                const orderInfo = await this.getOrderStatus(symbol, orderId);
                logger.log(`[${this.accountName}] ËÆ¢ÂçïÁä∂ÊÄÅ: ${orderInfo.status}, Â∑≤Êàê‰∫§: ${orderInfo.executedQty}/${orderInfo.origQty}`);
                
                if (orderInfo.status === 'FILLED') {
                    logger.log(`‚úÖ [${this.accountName}] ËÆ¢Âçï ${orderId} ÂÆåÂÖ®Êàê‰∫§ÔºÅ`);
                    return { success: true, orderInfo, filled: true };
                }
                
                if (orderInfo.status === 'PARTIALLY_FILLED') {
                    logger.log(`‚è≥ [${this.accountName}] ËÆ¢Âçï ${orderId} ÈÉ®ÂàÜÊàê‰∫§ÔºåÁªßÁª≠ÁõëÊéß...`);
                }
                
                if (['CANCELED', 'REJECTED', 'EXPIRED'].includes(orderInfo.status)) {
                    logger.log(`‚ùå [${this.accountName}] ËÆ¢Âçï ${orderId} Áä∂ÊÄÅ: ${orderInfo.status}`);
                    return { success: false, orderInfo, filled: false };
                }
                
                await new Promise(resolve => setTimeout(resolve, 3000));
                
            } catch (error) {
                logger.error(`[${this.accountName}] Êü•ËØ¢ËÆ¢ÂçïÁä∂ÊÄÅÂ§±Ë¥•: ${error.message}`);
                await new Promise(resolve => setTimeout(resolve, 5000));
            }
        }
        
        logger.log(`‚è∞ [${this.accountName}] ÁõëÊéßËÆ¢Âçï ${orderId} Ë∂ÖÊó∂`);
        return { success: false, orderInfo: null, filled: false, timeout: true };
    }
}

// ‰∏âË¥¶Âè∑ÂØπÂÜ≤‰∫§ÊòìÂ∑•ÂÖ∑Á±ª
class ThreeAccountHedgeTool {
    constructor() {
        this.account1 = new AsterFuturesAPI(api.api1.apiKey, api.api1.apiSecret, 'Ë¥¶Âè∑1', api.api1.proxy);
        this.account2 = new AsterFuturesAPI(api.api2.apiKey, api.api2.apiSecret, 'Ë¥¶Âè∑2', api.api2.proxy);
        this.account3 = new AsterFuturesAPI(api.api3.apiKey, api.api3.apiSecret, 'Ë¥¶Âè∑3', api.api3.proxy);
        this.accounts = [this.account1, this.account2, this.account3];
    }

    formatTime() {
        return new Date().toLocaleString('zh-CN');
    }

    // ÁîüÊàêÈöèÊú∫Êï∞ÈáèÔºàÂ∏¶ÂÆâÂÖ®Ê£ÄÊü•Ôºâ
    generateRandomQuantity() {
        const min = api.minQuantity || 0.001;
        const max = api.maxQuantity || 0.01;
        const quantity = Math.random() * (max - min) + min;
        
        // ÂÆâÂÖ®Ê£ÄÊü•ÔºöÁ°Æ‰øù‰∏çË∂ÖËøáÊúÄÂ§ßÊåÅ‰ªì‰ª∑ÂÄº
        const currentPrice = 112000; // ÂèØ‰ª•‰ªéAPIËé∑ÂèñÂÆûÊó∂‰ª∑Ê†º
        const positionValue = quantity * currentPrice;
        const maxValue = api.maxPositionValue || 2000;
        
        if (positionValue > maxValue) {
            const safeQuantity = maxValue / currentPrice;
            logger.log(`‚ö†Ô∏è ‰∏ãÂçïÈáëÈ¢ù ${positionValue.toFixed(2)} USDT Ë∂ÖËøáÈôêÂà∂ ${maxValue} USDTÔºåË∞ÉÊï¥‰∏∫ ${safeQuantity.toFixed(3)} BTC`);
            return parseFloat(safeQuantity.toFixed(3));
        }
        
        // BTCÂ∏ÇÂú∫ÈôêÂà∂‰∏∫3‰ΩçÂ∞èÊï∞
        return parseFloat(quantity.toFixed(3));
    }

    // ÈöèÊú∫ÂàÜÈÖçÈáëÈ¢ùÔºö‰∏ªË¥¶Âè∑ÈöèÊú∫ÈáëÈ¢ùÔºåËæÖË¥¶Âè∑ÈáëÈ¢ùÊÄªÂíåÁ≠â‰∫é‰∏ªË¥¶Âè∑
    generateQuantityDistribution() {
        const mainQuantity = this.generateRandomQuantity();
        const remainingQuantity = mainQuantity;
        
        // ÈöèÊú∫ÂàÜÈÖçÁªô‰∏§‰∏™ËæÖË¥¶Âè∑
        const ratio1 = Math.random();
        const ratio2 = 1 - ratio1;
        
        const quantity1 = remainingQuantity * ratio1;
        const quantity2 = remainingQuantity * ratio2;
        
        return {
            mainQuantity: parseFloat(mainQuantity.toFixed(3)),
            quantities: [
                parseFloat(quantity1.toFixed(3)),
                parseFloat(quantity2.toFixed(3))
            ]
        };
    }

    // ËÆæÁΩÆÊù†ÊùÜ
    async setLeverage(symbol, leverage) {
        logger.log(`\n=== [${this.formatTime()}] ËÆæÁΩÆÊù†ÊùÜ ===`);
        logger.log(`Â∏ÅÁßç: ${symbol}, Êù†ÊùÜ: ${leverage}x`);

        try {
            const results = await Promise.allSettled([
                this.account1.setLeverage(symbol, leverage),
                this.account2.setLeverage(symbol, leverage),
                this.account3.setLeverage(symbol, leverage)
            ]);

            results.forEach((result, index) => {
                if (result.status === 'fulfilled') {
                    logger.log(`‚úÖ Ë¥¶Âè∑${index + 1} ËÆæÁΩÆ ${leverage}x Êù†ÊùÜÊàêÂäü`);
                } else {
                    logger.log(`‚ùå Ë¥¶Âè∑${index + 1} ËÆæÁΩÆÊù†ÊùÜÂ§±Ë¥•: ${result.reason?.message || 'Êú™Áü•ÈîôËØØ'}`);
                }
            });

            return results;
        } catch (error) {
            logger.error(`ËÆæÁΩÆÊù†ÊùÜÂ§±Ë¥•: ${error.message}`);
            throw error;
        }
    }

    // ‰∏âË¥¶Âè∑Âæ™ÁéØÂØπÂÜ≤
    async loopHedge(config = {}) {
        const {
            symbol = api.symbol,
            leverage = api.leverage,
            positionTime = api.positionTime || 5,
            positionSide = 'BOTH',
            maxWaitTime = 300000
        } = config;

        logger.log(`\nüîÅ === [${this.formatTime()}] ÂêØÂä®‰∏âË¥¶Âè∑Âæ™ÁéØÂØπÂÜ≤ ===`);
        logger.log(`Â∏ÅÁßç: ${symbol}, Êù†ÊùÜ: ${leverage}x, ÊåÅ‰ªì: ${positionTime} ÂàÜÈíü`);
        logger.log(`üé≤ ÈöèÊú∫ÈÄâÊã©‰∏ªË¥¶Âè∑ÂíåËæÖË¥¶Âè∑ÔºåÈöèÊú∫ÂàÜÈÖçÈáëÈ¢ù`);
        let cycle = 0;

        const sleep = (ms) => new Promise(r => setTimeout(r, ms));

        try {
            await this.setLeverage(symbol, leverage);
        } catch (e) {
            logger.log(`‚ö†Ô∏è ËÆæÁΩÆÊù†ÊùÜÂ§±Ë¥•: ${e.message}, Â∞ÜÁªßÁª≠Â∞ùËØï‰∏ãÂçï`);
        }

        while (true) {
            cycle += 1;
            logger.log(`\n=== Âë®Êúü #${cycle} ÂºÄÂßã (${this.formatTime()}) ===`);
            
            try {
                // 1) ÈöèÊú∫ÈÄâÊã©‰∏ªË¥¶Âè∑
                const mainAccountIndex = Math.floor(Math.random() * 3);
                const mainAccount = this.accounts[mainAccountIndex];
                const mainAccountName = `Ë¥¶Âè∑${mainAccountIndex + 1}`;
                
                // Ëé∑ÂèñËæÖË¥¶Âè∑
                const helperAccounts = this.accounts.filter((_, index) => index !== mainAccountIndex);
                const helperAccountNames = helperAccounts.map((_, index) => {
                    const originalIndex = this.accounts.findIndex(acc => acc === helperAccounts[index]);
                    return `Ë¥¶Âè∑${originalIndex + 1}`;
                });

                logger.log(`üé≤ ÈöèÊú∫ÈÄâÊã©ÁªìÊûú:`);
                logger.log(`   ‰∏ªË¥¶Âè∑: ${mainAccountName} (ÂÅöÂ§ö)`);
                logger.log(`   ËæÖË¥¶Âè∑: ${helperAccountNames.join(', ')} (ÂÅöÁ©∫)`);

                // 2) ÁîüÊàêÈöèÊú∫ÈáëÈ¢ùÂàÜÈÖç
                const quantityDist = this.generateQuantityDistribution();
                logger.log(`üí∞ ÈáëÈ¢ùÂàÜÈÖç:`);
                logger.log(`   ‰∏ªË¥¶Âè∑ ${mainAccountName}: ${quantityDist.mainQuantity} ${symbol}`);
                logger.log(`   ËæÖË¥¶Âè∑ ${helperAccountNames[0]}: ${quantityDist.quantities[0]} ${symbol}`);
                logger.log(`   ËæÖË¥¶Âè∑ ${helperAccountNames[1]}: ${quantityDist.quantities[1]} ${symbol}`);
                logger.log(`   È™åËØÅ: ${quantityDist.quantities[0] + quantityDist.quantities[1]} = ${quantityDist.mainQuantity}`);

                // 3) Ëé∑Âèñ‰π∞‰∏Ä‰ª∑
                const bid1Price = await mainAccount.getBid1Price(symbol);
                logger.log(`üìä ÂΩìÂâç‰π∞‰∏Ä‰ª∑: ${bid1Price}`);

                // 4) ‰∏ªË¥¶Âè∑‰∏ãÈôê‰ª∑Âçï
                const limitOrder = await mainAccount.buyOrder(symbol, quantityDist.mainQuantity, bid1Price, 'LIMIT', positionSide);
                logger.log(`${mainAccountName} Èôê‰ª∑‰π∞ÂÖ•Êèê‰∫§: orderId=${limitOrder.orderId}, ‰ª∑Ê†º=${bid1Price}, Êï∞Èáè=${quantityDist.mainQuantity}`);

                // 5) ÁõëÊéß‰∏ªË¥¶Âè∑ËÆ¢ÂçïÊàê‰∫§
                const monitorResult = await mainAccount.monitorOrderStatus(symbol, limitOrder.orderId, maxWaitTime);
                if (!monitorResult.success) {
                    logger.log(`‚è≠Ô∏è ${mainAccountName}ËÆ¢ÂçïÊú™ÂÆåÂÖ®Êàê‰∫§ÔºåË∑≥ËøáÊú¨Âë®Êúü`);
                    continue;
                }

                const executedQty = parseFloat(monitorResult.orderInfo.executedQty);
                logger.log(`‚úÖ ${mainAccountName} Êàê‰∫§Êï∞Èáè: ${executedQty}`);

                // 6) ÊåâÊØî‰æãË∞ÉÊï¥ËæÖË¥¶Âè∑‰∏ãÂçïÊï∞Èáè
                const ratio = executedQty / quantityDist.mainQuantity;
                const adjustedQuantities = quantityDist.quantities.map(qty => qty * ratio);

                // 7) ËæÖË¥¶Âè∑Á´ãÂç≥Â∏Ç‰ª∑ÂØπÂÜ≤
                logger.log(`‚ö° ËæÖË¥¶Âè∑Á´ãÂç≥Â∏Ç‰ª∑ÂØπÂÜ≤...`);
                const hedgeResults = await Promise.allSettled([
                    helperAccounts[0].sellOrder(symbol, adjustedQuantities[0], null, 'MARKET', positionSide),
                    helperAccounts[1].sellOrder(symbol, adjustedQuantities[1], null, 'MARKET', positionSide)
                ]);

                hedgeResults.forEach((result, index) => {
                    if (result.status === 'fulfilled') {
                        logger.log(`‚úÖ ${helperAccountNames[index]} Â∏Ç‰ª∑ÂØπÂÜ≤ÂÆåÊàê: orderId=${result.value.orderId}, Êï∞Èáè=${adjustedQuantities[index]}`);
                    } else {
                        logger.error(`‚ùå ${helperAccountNames[index]} Â∏Ç‰ª∑ÂØπÂÜ≤Â§±Ë¥•: ${result.reason?.message}`);
                    }
                });

                // 8) ÊåÅ‰ªì
                const holdMs = Math.max(1, positionTime) * 60 * 1000;
                logger.log(`‚è±Ô∏è ÊåÅ‰ªì ${positionTime} ÂàÜÈíü...`);
                await sleep(holdMs);

                // 9) ÂêåÊó∂Âπ≥‰ªì
                logger.log(`\nüßπ ÂêåÊó∂Âπ≥‰ªì‰∏≠...`);
                const closeResults = await Promise.allSettled([
                    this.account1.closePosition(symbol),
                    this.account2.closePosition(symbol),
                    this.account3.closePosition(symbol)
                ]);

                closeResults.forEach((result, index) => {
                    if (result.status === 'fulfilled') {
                        if (result.value) {
                            logger.log(`‚úÖ Ë¥¶Âè∑${index + 1} Âπ≥‰ªìÊàêÂäü`);
                        } else {
                            logger.log(`‚ÑπÔ∏è Ë¥¶Âè∑${index + 1} Êó†ÈúÄÂπ≥‰ªì`);
                        }
                    } else {
                        logger.error(`‚ùå Ë¥¶Âè∑${index + 1} Âπ≥‰ªìÂ§±Ë¥•: ${result.reason?.message}`);
                    }
                });

                logger.log(`üéâ Âπ≥‰ªìÂÆåÊàêÔºåÂáÜÂ§áËøõÂÖ•‰∏ã‰∏ÄËΩÆ`);
            } catch (err) {
                logger.error(`‚ùå Âë®Êúü #${cycle} Â§±Ë¥•: ${err.message}`);
                logger.log(`üïí ‰ºëÁú† 5 ÁßíÂêéÁªßÁª≠‰∏ã‰∏ÄËΩÆ...`);
                await sleep(5000);
            }
        }
    }

    // Êü•ËØ¢ÊâÄÊúâË¥¶Âè∑ÊåÅ‰ªìÁä∂ÊÄÅ
    async checkAllPositions(symbol = api.symbol) {
        logger.log(`\nüìä === [${this.formatTime()}] ‰∏âË¥¶Âè∑ÊåÅ‰ªìÁä∂ÊÄÅ ===`);
        
        try {
            const results = await Promise.allSettled([
                this.account1.getPositions(symbol),
                this.account2.getPositions(symbol),
                this.account3.getPositions(symbol)
            ]);

            logger.log(`Â∏ÅÁßç: ${symbol}`);

            results.forEach((result, index) => {
                if (result.status === 'fulfilled' && result.value) {
                    const pos = result.value.find(p => parseFloat(p.positionAmt) !== 0);
                    if (pos) {
                        logger.log(`Ë¥¶Âè∑${index + 1} ÊåÅ‰ªì: ${pos.positionAmt} ${symbol}`);
                        logger.log(`   ÂºÄ‰ªìÂùá‰ª∑: ${pos.entryPrice} USDT`);
                        logger.log(`   Êú™ÂÆûÁé∞Áõà‰∫è: ${pos.unRealizedProfit} USDT`);
                        logger.log(`   Êù†ÊùÜÂÄçÊï∞: ${pos.leverage}x`);
                    } else {
                        logger.log(`Ë¥¶Âè∑${index + 1}: Êó†ÊåÅ‰ªì`);
                    }
                } else {
                    logger.error(`Ë¥¶Âè∑${index + 1} Êü•ËØ¢Â§±Ë¥•: ${result.reason?.message}`);
                }
            });

            return results;
        } catch (error) {
            logger.error(`Êü•ËØ¢ÊåÅ‰ªìÂ§±Ë¥•: ${error.message}`);
            throw error;
        }
    }

    // ÂêåÊó∂Âπ≥‰ªìÊâÄÊúâË¥¶Âè∑
    async closeAllPositions(symbol = api.symbol) {
        logger.log(`\nüîÑ === [${this.formatTime()}] ‰∏âË¥¶Âè∑ÂêåÊó∂Âπ≥‰ªì ===`);
        logger.log(`Â∏ÅÁßç: ${symbol}`);

        try {
            // ÂÖàÊ£ÄÊü•ÊòØÂê¶ÊúâÊåÅ‰ªì
            const positions = await Promise.allSettled([
                this.account1.getPositions(symbol),
                this.account2.getPositions(symbol),
                this.account3.getPositions(symbol)
            ]);

            let hasPositions = false;
            positions.forEach((result, index) => {
                if (result.status === 'fulfilled' && result.value) {
                    const pos = result.value.find(p => parseFloat(p.positionAmt) !== 0);
                    if (pos) {
                        hasPositions = true;
                        logger.log(`Ë¥¶Âè∑${index + 1} ÂèëÁé∞ÊåÅ‰ªì: ${pos.positionAmt} ${symbol}`);
                    }
                }
            });

            if (!hasPositions) {
                logger.log(`‚úÖ ÊâÄÊúâË¥¶Âè∑ÂùáÊó† ${symbol} ÊåÅ‰ªìÔºåÊó†ÈúÄÂπ≥‰ªì`);
                return [];
            }

            // ÊâßË°åÂπ≥‰ªì
            const results = await Promise.allSettled([
                this.account1.closePosition(symbol),
                this.account2.closePosition(symbol),
                this.account3.closePosition(symbol)
            ]);

            results.forEach((result, index) => {
                if (result.status === 'fulfilled') {
                    if (result.value) {
                        logger.log(`‚úÖ Ë¥¶Âè∑${index + 1} Âπ≥‰ªìÊàêÂäü`);
                    } else {
                        logger.log(`‚ÑπÔ∏è Ë¥¶Âè∑${index + 1} Êó†ÈúÄÂπ≥‰ªì`);
                    }
                } else {
                    logger.error(`‚ùå Ë¥¶Âè∑${index + 1} Âπ≥‰ªìÂ§±Ë¥•: ${result.reason?.message}`);
                }
            });

            return results;
        } catch (error) {
            logger.error(`Âπ≥‰ªìÊìç‰ΩúÂ§±Ë¥•: ${error.message}`);
            throw error;
        }
    }


    // ÊòæÁ§∫ÂΩìÂâçÈÖçÁΩÆÂíåÈ£éÈô©ÂàÜÊûê
    showConfigAnalysis() {
        const currentPrice = 112000; // BTC‰ª∑Ê†º
        const minValue = (api.minQuantity || 0.001) * currentPrice;
        const maxValue = (api.maxQuantity || 0.01) * currentPrice;
        const leverage = api.leverage || 20;
        
        logger.log(`\nüìä === ÂΩìÂâçÈÖçÁΩÆÂàÜÊûê ===`);
        logger.log(`Â∏ÅÁßç: ${api.symbol}`);
        logger.log(`Êù†ÊùÜ: ${leverage}x`);
        logger.log(`BTC‰ª∑Ê†º: ${currentPrice.toLocaleString()} USDT`);
        logger.log(`\nüí∞ ‰∏ãÂçïÈáëÈ¢ùÂàÜÊûê:`);
        logger.log(`ÊúÄÂ∞è‰∏ãÂçï: ${api.minQuantity || 0.001} BTC = ${minValue.toFixed(2)} USDT`);
        logger.log(`ÊúÄÂ§ß‰∏ãÂçï: ${api.maxQuantity || 0.01} BTC = ${maxValue.toFixed(2)} USDT`);
        logger.log(`\nüõ°Ô∏è ‰øùËØÅÈáëÈúÄÊ±Ç:`);
        logger.log(`ÊúÄÂ∞è‰øùËØÅÈáë: ${(minValue / leverage).toFixed(2)} USDT`);
        logger.log(`ÊúÄÂ§ß‰øùËØÅÈáë: ${(maxValue / leverage).toFixed(2)} USDT`);
        logger.log(`\n‚ö†Ô∏è È£éÈô©ÊéßÂà∂:`);
        logger.log(`ÊúÄÂ§ßÊåÅ‰ªì‰ª∑ÂÄºÈôêÂà∂: ${api.maxPositionValue || 2000} USDT`);
        logger.log(`ÊúÄÂ∞èË¥¶Êà∑‰ΩôÈ¢ùË¶ÅÊ±Ç: ${api.minAccountBalance || 100} USDT`);
        
        // ‰ª£ÁêÜÁä∂ÊÄÅ
        logger.log(`\nüåê ‰ª£ÁêÜÁä∂ÊÄÅ:`);
        this.accounts.forEach((account, index) => {
            const config = account.proxyConfig;
            logger.log(`Ë¥¶Âè∑${index + 1}: ${config?.enabled ? '‚úÖ Â∑≤ÂêØÁî®' : '‚ùå Êú™ÂêØÁî®'} ${config?.url || ''}`);
        });
        
        // È£éÈô©Á≠âÁ∫ßËØÑ‰º∞
        const riskLevel = maxValue > 1000 ? 'üî¥ È´òÈ£éÈô©' : maxValue > 500 ? 'üü° ‰∏≠È£éÈô©' : 'üü¢ ‰ΩéÈ£éÈô©';
        logger.log(`\nüìà È£éÈô©Á≠âÁ∫ß: ${riskLevel}`);
        
        if (maxValue > (api.maxPositionValue || 2000)) {
            logger.log(`‚ö†Ô∏è Ë≠¶Âëä: ÊúÄÂ§ß‰∏ãÂçïÈáëÈ¢ùÂèØËÉΩË∂ÖËøáÊåÅ‰ªìÈôêÂà∂ÔºÅ`);
        }
    }

}


// ÂØºÂá∫
module.exports = { ThreeAccountHedgeTool, AsterFuturesAPI, Logger };

// Â¶ÇÊûúÁõ¥Êé•ËøêË°åÊ≠§Êñá‰ª∂ÔºåÊâßË°åËá™Âä®ÂåñÊµÅÁ®ã
if (require.main === module) {
    runAutomatedFlow().catch(error => {
        logger.error(`Á®ãÂ∫èÊâßË°åÂ§±Ë¥•: ${error.message}`);
        process.exit(1);
    });
}

// Ëá™Âä®ÂåñÊâßË°åÊµÅÁ®ã
async function runAutomatedFlow() {
    const tool = new ThreeAccountHedgeTool();
    
    // ËÆæÁΩÆ‰ºòÈõÖÈÄÄÂá∫Â§ÑÁêÜ
    process.on('SIGINT', async () => {
        logger.log('\n\nüõë Êé•Êî∂Âà∞ÈÄÄÂá∫‰ø°Âè∑ÔºåÊ≠£Âú®ÂÆâÂÖ®ÈÄÄÂá∫...');
        try {
            logger.log('üìã Ê≠£Âú®Âπ≥‰ªìÊâÄÊúâÊåÅ‰ªì...');
            await tool.closeAllPositions();
            logger.log('‚úÖ ÂÆâÂÖ®ÈÄÄÂá∫ÂÆåÊàê');
        } catch (error) {
            logger.error(`ÈÄÄÂá∫Êó∂Âπ≥‰ªìÂ§±Ë¥•: ${error.message}`);
        }
        process.exit(0);
    });
    
    try {
        logger.log('üöÄ === Aster ‰∏âË¥¶Âè∑ÂØπÂÜ≤‰∫§ÊòìÂ∑•ÂÖ∑ÂêØÂä® ===');
        
        // Ê≠•È™§1: Ê£ÄÊü•Âπ∂Âπ≥‰ªìÊâÄÊúâË¥¶Êà∑ÁöÑ‰ªì‰Ωç
        logger.log('\nüìã === Ê≠•È™§1: Ê£ÄÊü•Âπ∂Âπ≥‰ªìÁé∞Êúâ‰ªì‰Ωç ===');
        await tool.closeAllPositions();
        
        // Ê≠•È™§2: ÊâìÂç∞ÂΩìÂâçÈÖçÁΩÆÂíåÈ£éÈô©ÂàÜÊûê
        logger.log('\nüìä === Ê≠•È™§2: ÈÖçÁΩÆÂíåÈ£éÈô©ÂàÜÊûê ===');
        tool.showConfigAnalysis();
        
        // Ê≠•È™§3: ÂºÄÂêØÂæ™ÁéØÂØπÂÜ≤
        logger.log('\nüîÑ === Ê≠•È™§3: ÂêØÂä®Âæ™ÁéØÂØπÂÜ≤ ===');
        logger.log('Êåâ Ctrl+C ÂèØÈöèÊó∂ÂÅúÊ≠¢Âæ™ÁéØÂπ∂ÂÆâÂÖ®ÈÄÄÂá∫');
        await tool.loopHedge();
        
    } catch (error) {
        logger.error(`Ëá™Âä®ÂåñÊµÅÁ®ãÊâßË°åÂ§±Ë¥•: ${error.message}`);
        throw error;
    }
}